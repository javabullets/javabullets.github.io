---
id: 608
title: 'Spring Data JPA &#8211; Top and First'
date: '2016-06-30T13:48:43+00:00'
author: 'Martin Farrell'
layout: post
guid: 'https://glenware.wordpress.com/?p=608'
permalink: /my-favourite-spring-data-jpa-feature/
thrive_post_fonts:
    - '[]'
image: /wp-content/uploads/2016/06/lesly-b-juarez-210813.jpg
categories:
    - Java
    - 'Spring Data'
    - SQL
tags:
    - JPA
    - 'Spring Data'
    - 'Spring Data JPA'
---

I like Spring Data JPA. It helps simplify your codebase, and frees me up from writing JPAQL or SQL. I’m also impressed by the complexity of query you can write using Spring Data. My favourite Spring Data JPA feature is top and first, which returns the first or top records from a table

# Spring Data JPA – Top and First

Lets say I have a table tracking document versions –

DOCUMENT\_TABLE

| DOCUMENT\_ID | NAME | VERSION |
|---|---|---|
| 1 | mydoc.doc | 1 |
| 2 | mydoc.doc | 2 |
| 3 | mydoc.doc | 3 |

With its associated JPA object –

```
<pre class="">@Entity
 @Table(name = "DOCUMENT_TABLE")
 public class Document implements Serializable {
 private static final long serialVersionUID = 1L;

@Id
 @Column(name = "DOCUMENT_ID")
 private Long documentId;

@Basic(optional = false)
 @NotNull
 private String name;

@Basic(optional = false)
 @NotNull
 private Long version;

}

```

My SQL would be –

```
<pre class="">SELECT *
 FROM
 (SELECT *
 FROM document_table dt
 WHERE dt.name = 'mydoc.doc'
 ORDER BY dt.VERSION DESC
 )
 WHERE rownum = 1;

```

Or in JPA –

```
<pre class=""> select d
 from Document d
 where d.name = :name
 and d.version = (select max(d.version) from Document d where d.name = :name)
```

But I want to keep my codebase consistent so the first thing I can try is –

```
<pre class=""> public interface DocumentRepository extends CrudRepository<Document, Long> {
 List<Document> findByNameOrderByVersionDesc(String name);
 }
```

I can get the first record –

```
<pre class="">List<Document> documentList =
 documentRepository.findByNameOrderByVersionDesc("mydoc.doc");
 Document document = documentList.get(0);
```

Thats Ok I guess. Another alternative is to have a straight SQL query in the repository, but the best option is to use the Top feature in spring data –

```
<pre class="">public interface DocumentRepository extends CrudRepository<Document, Long> {
 Document findFirstByNameOrderByVersionDesc(String name);
 Document findTopByNameOrderByVersionDesc(String name);
 }
```

The above methods are equivalent

We can even use Top to return the top n records –

```
<pre class="">Document findTop2ByNameOrderByVersionDesc(String name);
```

Interestingly the underlying SQL generated by Spring Data opts for the rownum construct I used in my original SQL statement