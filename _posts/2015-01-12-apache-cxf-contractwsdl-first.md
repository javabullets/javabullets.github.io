---
id: 368
title: 'Apache CXF &#8211; Contract/WSDL First'
date: '2015-01-12T20:09:00+00:00'
author: 'Martin Farrell'
layout: post
guid: 'https://glenware.wordpress.com/?p=368'
permalink: /apache-cxf-contractwsdl-first/
thrive_post_fonts:
    - '[]'
categories:
    - Spring
    - 'Web Services'
tags:
    - 'Apache CXF'
    - 'Contract First'
    - wsdl
---

I introduced Apache CXF in my last post. I planned on writing some good examples of my own on using the framework, but to be honest I would struggle to beat the time and depth of examples the CXF download provides in its samples directory(Apache CXF Version 3)

Instead I decided it would be more interesting to provide commentary to some of these examples, including –

- [WSDL First Demo](https://www.javabullets.com/2015/01/12/apache-cxf-contractwsdl-first/)
- [Contract Last](https://www.javabullets.com/2015/01/12/apache-cxf-contract-last-example/)
- [JMS Queue](https://www.javabullets.com/2015/01/12/apache-cxf-jms-queue/)
- [JMS Spring Config](https://www.javabullets.com/2015/01/13/jms-spring-config-demo/)
- [RESTful Services](https://www.javabullets.com/2015/01/15/apache-cxf-jax-rs/)

Thanks to the Apache CXF developers for providing this software, and these great examples. All code contained in this post is released by Apache under the Apache License.

**WSDL First Demo**

There are two approaches to building web services – contract first and contract last. Contract first is where the wsdl is defined first, and contract last is where the wsdl is defined last. Apache CXF supports both forms of development.

This example is found under [apache-cxf\\samples\\wsdl\_first](https://fisheye6.atlassian.com/browse/cxf/distribution/src/main/release/samples/wsdl_first), and is an examples of a contract first application

**WSDL Contract**

The wsdl follows the standard structure –

- wsdl:types
- wsdl:message
- wsdl:operation
- wsdl:binding
- wsdl:service

It defines 2 operations –

- &lt;wsdl:operation name=”updateCustomer”&gt;
- &lt;wsdl:operation name=”getCustomersByName”&gt;

Finally the service defines 2 endpoints, one for standalone, and one for a tomcat deployment –

\[sourcecode lang=”xml”\] &lt;wsdl:service name="CustomerServiceService"&gt;  
 &lt;wsdl:port name="CustomerServicePort" binding="tns:CustomerServiceServiceSoapBinding"&gt;  
 &lt;!– embedded deployment –&gt;  
 &lt;soap:address location="http://localhost:8080/wsdl\_first/services/CustomerServicePort"/&gt;  
 &lt;!– Tomcat deployment, embedded or standalone –&gt;  
 &lt;!–soap:address location="http://localhost:8080/wsdl\_first/services/CustomerServicePort"/–&gt;  
 &lt;/wsdl:port&gt;  
 &lt;/wsdl:service&gt;  
\[/sourcecode\] **Web Service Implementation – CustomerServiceImpl**

The CustomerServiceImpl implements the CustomerService interface, which is created through the maven task – [wsdl2java](http://cxf.apache.org/docs/maven-cxf-codegen-plugin-wsdl-to-java.html)

\[sourcecode lang=”java”\] public class CustomerServiceImpl implements CustomerService {  // The WebServiceContext can be used to retrieve special attributes like the  
 // user principal. Normally it is not needed  
 @Resource  
 WebServiceContext wsContext;

 public List&amp;amp;lt;Customer&amp;amp;gt; getCustomersByName(String name) throws NoSuchCustomerException {  
 // …  
 }

 public void updateCustomer(Customer customer) {  
 // …  
 }

}  
\[/sourcecode\]

The interface itself looks like, where you can see the autogenerated JAX-WS annotations –

\[sourcecode lang=”java”\] @WebService(targetNamespace = &amp;amp;quot;http://customerservice.example.com/&amp;amp;quot;, name = &amp;amp;quot;CustomerService&amp;amp;quot;)  
@XmlSeeAlso({ObjectFactory.class})  
public interface CustomerService {  @Oneway  
 @RequestWrapper(localName = &amp;amp;quot;updateCustomer&amp;amp;quot;,  
 targetNamespace = &amp;amp;quot;http://customerservice.example.com/&amp;amp;quot;,  
 className = &amp;amp;quot;com.example.customerservice.UpdateCustomer&amp;amp;quot;)  
 @WebMethod  
 public void updateCustomer(@WebParam(name = &amp;amp;quot;customer&amp;amp;quot;, targetNamespace = &amp;amp;quot;&amp;amp;quot;)  
 com.example.customerservice.Customer customer  
 );

 @WebResult(name = &amp;amp;quot;return&amp;amp;quot;, targetNamespace = &amp;amp;quot;&amp;amp;quot;)  
 @RequestWrapper(localName = &amp;amp;quot;getCustomersByName&amp;amp;quot;,  
 targetNamespace = &amp;amp;quot;http://customerservice.example.com/&amp;amp;quot;,  
 className = &amp;amp;quot;com.example.customerservice.GetCustomersByName&amp;amp;quot;)  
 @WebMethod  
 @ResponseWrapper(localName = &amp;amp;quot;getCustomersByNameResponse&amp;amp;quot;,  
 targetNamespace = &amp;amp;quot;http://customerservice.example.com/&amp;amp;quot;,  
 className = &amp;amp;quot;com.example.customerservice.GetCustomersByNameResponse&amp;amp;quot;)  
 public java.util.List&amp;amp;lt;com.example.customerservice.Customer&amp;amp;gt; getCustomersByName(  
 @WebParam(name = &amp;amp;quot;name&amp;amp;quot;, targetNamespace = &amp;amp;quot;&amp;amp;quot;) java.lang.String name  
 ) throws NoSuchCustomerException;

}  
\[/sourcecode\]

**CXFServlet**

web.xml defines the CXFServlet –

\[sourcecode lang=”xml”\] &lt;servlet&gt;  
 &lt;description&gt;Apache CXF Endpoint&lt;/description&gt;  
 &lt;display-name&gt;cxf&lt;/display-name&gt;  
 &lt;servlet-name&gt;cxf&lt;/servlet-name&gt;  
 &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt;  
 &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  
 &lt;/servlet&gt;  
 &lt;servlet-mapping&gt;  
 &lt;servlet-name&gt;cxf&lt;/servlet-name&gt;  
 &lt;url-pattern&gt;/services/\*&lt;/url-pattern&gt;  
 &lt;/servlet-mapping&gt;  
\[/sourcecode\] The CXFServlet adds a Spring context, which is defined through a file called cxf.xml. This defines the end point, this is the default name and could be changed through web.xml configuration –

\[sourcecode lang=”xml”\] &lt;!– comment this bean to disable schema validation in the client –&gt;  
 &lt;jaxws:client name="{http://apache.org/hello\_world\_soap\_http}SoapPort" createdFromAPI="true"&gt;  
 &lt;jaxws:properties&gt;  
 &lt;entry key="schema-validation-enabled" value="true"/&gt;  
 &lt;/jaxws:properties&gt;  
 &lt;/jaxws:client&gt;  
 &lt;jaxws:endpoint name="{http://apache.org/hello\_world\_soap\_http}SoapPort"  
 wsdlLocation="wsdl/CustomerService.wsdl" createdFromAPI="true"&gt;  
 &lt;jaxws:properties&gt;  
 &lt;entry key="schema-validation-enabled" value="true"/&gt;  
 &lt;/jaxws:properties&gt;  
 &lt;/jaxws:endpoint&gt;  
\[/sourcecode\] **Server Implementation**

The intention of this tutorial is to deploy to JBoss Fuse, but I thought it was interesting to look at the different options offered in this example. The first uses JAX-WS or Spring

Spring – Injection of endpoint into jaxws server –

\[sourcecode lang=”xml”\] &lt;!– HTTP Endpoint –&gt;  
&lt;jaxws:endpoint xmlns:customer="http://customerservice.example.com/" id="CustomerServiceHTTP" address="http://localhost:8080/wsdl\_first/services/CustomerServicePort" serviceName="customer:CustomerServiceService" endpointName="customer:CustomerServiceEndpoint" implementor="com.example.customerservice.server.CustomerServiceImpl"&gt;  
 &lt;jaxws:features&gt;  
 &lt;bean class="org.apache.cxf.feature.LoggingFeature"/&gt;  
 &lt;/jaxws:features&gt;  
&lt;/jaxws:endpoint&gt;  
\[/sourcecode\] JAX-WS – The Endpoint is coded directly –

\[sourcecode lang=”java”\] CustomerService implementor = new CustomerServiceImpl();  
EndpointImpl ep = (EndpointImpl)  
Endpoint.publish(&amp;amp;quot;http://localhost:8080/wsdl\_first/services/CustomerServicePort&amp;amp;quot;, implementor); // Adding logging for incoming and outgoing messages  
ep.getServer().getEndpoint().getInInterceptors().add(new LoggingInInterceptor());  
ep.getServer().getEndpoint().getOutInterceptors().add(new LoggingOutInterceptor());  
\[/sourcecode\]

**Build (pom.xml)**

The core part of the pom is the cxf-codegen-plugin. This plugin takes the wsdl and generates the java source code through its wsdl2java goal –

\[sourcecode lang=”xml”\] &lt;plugin&gt;  
 &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;  
 &lt;artifactId&gt;cxf-codegen-plugin&lt;/artifactId&gt;  
 &lt;version&gt;${project.version}&lt;/version&gt;  
 &lt;executions&gt;  
 &lt;execution&gt;  
 &lt;id&gt;generate-sources&lt;/id&gt;  
 &lt;phase&gt;generate-sources&lt;/phase&gt;  
 &lt;configuration&gt;  
 &lt;wsdlOptions&gt;  
 &lt;wsdlOption&gt;  
 &lt;wsdl&gt;src/main/resources/CustomerService.wsdl&lt;/wsdl&gt;  
 &lt;frontEnd&gt;jaxws21&lt;/frontEnd&gt;  
 &lt;faultSerialVersionUID&gt;1&lt;/faultSerialVersionUID&gt;  
 &lt;bindingFiles&gt;  
 &lt;bindingFile&gt;src/main/resources/binding.xml&lt;/bindingFile&gt;  
 &lt;/bindingFiles&gt;  
 &lt;/wsdlOption&gt;  
 &lt;/wsdlOptions&gt;  
 &lt;/configuration&gt;  
 &lt;goals&gt;  
 &lt;goal&gt;wsdl2java&lt;/goal&gt;  
 &lt;/goals&gt;  
 &lt;/execution&gt;  
 &lt;/executions&gt;  
 &lt;/plugin&gt;  
\[/sourcecode\] Key points –

- &lt;id&gt; and &lt;phase&gt; – generate-sources
- &lt;wsdl&gt; – allows multiple wsdls
- &lt;binding&gt; – This is a specific binding for Java to use Java consistent date formats instead of the default XMLGregorianCalendar

**Putting it all together**

The tutorial instructions are quite simple –

*mvn clean install*  (builds the demo and creates a WAR file for optional Tomcat deployment)  
 *mvn -Pserver* (from one command line window — only if using embedded Jetty)  
 *mvn -Pclient* (from a second command line window)

Or change the CustomerService.wsdl, and rerun maven. Then copy the wsdl\_first.war to the deploy directory of tomcat. You can test the installation by running –

*http://localhost:8080/wsdl\_first/services/CustomerServicePort?wsdl*

You can then test this installation using a tool like SOAPUI, and sending a message like –

\[sourcecode lang=”xml”\] &lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:cus="http://customerservice.example.com/"&gt;  
 &lt;soapenv:Header/&gt;  
 &lt;soapenv:Body&gt;  
 &lt;cus:getCustomersByName&gt;  
 &lt;!–Optional:–&gt;  
 &lt;name&gt;Martin&lt;/name&gt;  
 &lt;/cus:getCustomersByName&gt;  
 &lt;/soapenv:Body&gt;  
&lt;/soapenv:Envelope&gt;  
\[/sourcecode\] Or to update the customer –

\[sourcecode lang=”xml”\] &lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:cus="http://customerservice.example.com/"&gt;  
 &lt;soapenv:Header/&gt;  
 &lt;soapenv:Body&gt;  
 &lt;cus:updateCustomer&gt;  
 &lt;!–Optional:–&gt;  
 &lt;customer&gt;  
 &lt;customerId&gt;0&lt;/customerId&gt;  
 &lt;!–Optional:–&gt;  
 &lt;name&gt;Smith&lt;/name&gt;  
 &lt;/customer&gt;  
 &lt;/cus:updateCustomer&gt;  
 &lt;/soapenv:Body&gt;  
&lt;/soapenv:Envelope&gt;  
\[/sourcecode\] The tomcat log shows the interaction

```

update request was received
Customer was updated
```